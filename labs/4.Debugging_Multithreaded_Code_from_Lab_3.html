<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

        
            <link rel="icon" href="../assets/sibin.integral.favicon.ico">
        

        <link rel="stylesheet" href="../assets/reveal-js/dist/reveal.css" />

        
            <link rel="stylesheet" href="../assets/custom.sibin.css" />
        
        
            <link rel="stylesheet" href="../assets/monokai.css" />
        

        
            
        
            
        
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown
                
                    data-separator="^\s*---\s*$"
                
                    data-separator-vertical="^\s*-v-\s*$"
                
                    data-separator-notes="^Notes?:"
                
                    data-charset="utf-8"
                
                    data-auto-animate="True"
                
                >
                    <textarea data-template>
                        ## **Lab 4** | Debugging Multithreaded Code from Lab 3

### Design of Autonomous Systems  
### CSCI 6907/4907 - Section 86  
### Prof. **Sibin Mohan**

---

## **Lab Overview**

In this Lab session, we will,

- Debug Multithreaded Code
    - Multithreading Safe vs Unsafe Functions
    - Killing a Multithreaded program
    - Using Delays (e.g., sleep ) and loops, practically 
- Learn More about Synchronization
    - Sharing big data structures (not just simple atomics)
    - Printing and Flushing print Buffers

---

## **Multithreading Safe vs Unsafe Functions**

- Not all function can be called simultaneously from multiple threads
- E.g. the init() function as,
- Initialization functions are typically,
    - supposed to run once
    - from any thread
    - and update a global state (e.g., a file descriptor)
- Furthermore, functions using this global state need,
    - to wait for the initialization to finish
- In Lab 3 code, the init function was,
    - being called multiple times
    - from 2 different threads
    - thus init runs multiple times causing many problems
- Many linux APIs are marked MT-Safe or UnSafe for this reason
- Lets Jump into to see it getting fixed

---

## **Killing a Multithreaded Program**

- Killing a multithreaded program isn’t simple
    - especially when we need to do cleanup before quitting
- Pressing Ctrl+C might not kill all the threads so,
    - all threads must check an exit signal to stop
    - this means no unbounded loops
        - e.g., no   `while (true) { ...}`
- A signal can simply be a global `std::atomic<bool>` running;
- So every loop in every thread is bounded by this signal
    - E.g.   `while (true) { running.load() || <other cotd.> }`
- Furthermore, during exit
    - it’s  best to do some cleanup e.g
        - setting all the GPIOs to OFF
        - freeing up some special files/registers in a certain way
    - only one thread should do this clean-up
- Lets jump into the code and see how that’s done


---

## **Using delays and loops, practically!**

- Apart from avoiding unbounded loops, it’s a good idea to,
    - use timeouts — even for bounded loops
        - e.g., waiting for echo from the ultrasonic
- Most sensors don’t run at 2.4Ghz (CPU Speeds) so,
    - find out (estimate) the frequency you need to read the sensor at
    - find out what frequency the sensor can work at
    - use the lower number from the two
    - This,
        - prevents sensor overuse (overheating)
        - improves system speed
        - reduces reading errors
            - reading the sensor too fast means glitchy readings
- Reading speed can be controlled by adding delays
    - e.g., adding sleep(0.5) forces a reading loop  to <2Hz
- Lets jump into the code and see how that’s done


---

## **Takeaways**

- Although it seems simple, multithreaded programs need careful design as,
    - Simple functions aren’t simple in multithreaded environment
    - Exiting cleanly matters when dealing with sensors and actuators
    - Unbounded loops are a recipe for disaster
    - Timeouts are critical to stable system

---

**More about Synchronization**

---

## **Sharing big data structures**

- Sharing data across multiple thread is easy when using atomics
    - however, atomics are limited size (e.g a float or an int)
- Thus, when we need to share bigger objects,
    - e.g., a struct containing rover’s position, heading and velocity
- we use locks (e.g., a mutex), this enables us to use
    - big structures
- Access can also be optimized by breaking up big structs into smaller ones
    - e.g., if one thread doesn’t need all of the fields, have a separate lock
- Access sequence can also be optimized to prioritize certain threads
    - e.g., main control thread access priority supersedes other threads
- Lets jump into the code and see how that’s done


---

## **Printing and Flushing print Buffers**

- Printing is one of the fundamental ways to interact/understand prog. state
- However, with multithreaded embedded systems one should be careful as,
    - UART does not work as fast as ssh
        - thus, printing and then flushing to UART slows the process down
    - Multiple threads printing together makes everything jumbled and hard to debug
        - i use different colored print to understand things better
        - avoid printing without newlines
    - Avoid printing too much and too many times
        - printing a lot significantly slows down the system
        - always avoid printing in hot paths
        - 1Hz total printing rate is idea


---

**End of Lab-1**

---
                    </textarea>
                </section>
            </div>
        </div>
        <script src="../assets/reveal-js/dist/reveal.js"></script>
        <script src="../assets/reveal-js/plugin/markdown/markdown.js"></script>
        <script src="../assets/reveal-js/plugin/highlight/highlight.js"></script>
        <script src="../assets/reveal-js/plugin/zoom/zoom.js"></script>
        <script src="../assets/reveal-js/plugin/notes/notes.js"></script>
        <script src="../assets/reveal-js/plugin/math/math.js"></script>

        
            
                
                    
                        <script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin/plugin/mermaid/mermaid.min.js"></script>
                    
                
            
                
                    
                        <script src="https://cdn.jsdelivr.net/npm/reveal-plantuml/dist/reveal-plantuml.min.js"></script>
                    
                
            
        

        <script>
            Reveal.initialize({
                
                    
                        history: true,
                    
                        slideNumber: "c/t",
                    
                        height: 1080,
                    
                        width: 1920,
                    
                        transition: "fade",
                    
                        backgroundTransition: "slide",
                    
                        RevealMermaid: {"htmlLabels": true, "useMaxWidth": true},
                    
                
                plugins: [
                    RevealMarkdown,
                    RevealHighlight,
                    RevealZoom,
                    RevealNotes,
                    RevealMath,

                    
                        
                            
                                RevealMermaid,
                            
                        
                            
                        
                    
                ],
            });
        </script>
    </body>
</html>